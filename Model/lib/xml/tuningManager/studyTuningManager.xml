<?xml version="1.0" encoding="UTF-8"?>
<tuningConfig>


  <!-- TODO:  add filterValue here if/when Dataset specific run gets Samples;
              until then this query will return zero rows in clinepi context -->
  <tuningTable name="SampleId" prefixEnabled="true">
    <comment>Which protocol app nodes for sample record
    </comment>
    <externalDependency name="core.ProjectInfo"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.Study"/>
    <externalDependency name="study.StudyLink"/>
    <sql>
      <![CDATA[
          create table &prefixSampleId&1 as
          select pan.protocol_app_node_id as pan_id, pan.name as pan_name,
                 pi.name as project_id
          from study.ProtocolAppNode pan, core.ProjectInfo pi
          where pan.isa_type = 'Sample'
            and pan.row_project_id = pi.project_id
        union
          select pan.protocol_app_node_id as pan_id, pan.name as pan_name,
                 pi.name as project_id
          from study.Study s, sres.ExternalDatabase d,
               sres.ExternalDatabaseRelease r, study.ProtocolAppNode pan,
               study.StudyLink sl, core.ProjectInfo pi
          where s.external_database_release_id = r.external_database_release_id
            and r.external_database_id = d.external_database_id
            and s.study_id = sl.study_id
            and pan.row_project_id = pi.project_id
            and sl.protocol_app_node_id = pan.protocol_app_node_id
            and d.name like '%isolates_genbank_RSRC'
        -- using column positions, rather than column names, in ORDER BY on union
        order by 2, 1
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="OntologyRelation" prefixEnabled="true">
    <comment>Each record represents a parent-child relation within an ontology
             dataset. Used to build the Ontology tuning table, which adds info
             particular to a (data) dataset, such as property types and
             dataset-specific display names.
    </comment>
    <internalDependency name="HierarchyMap"/>
    <externalDependency name="sres.OntologyRelationship"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
        create table &prefixOntologyRelation&1 nologging as
        select ed.name as hierarchy_dataset_name,
               edr.external_database_release_id as hierarchy_dataset_release_id,
               child.ontology_term_id as child_ontology_term_id,
               child.source_id as child_ontology_term_source_id,
               parent.ontology_term_id as parent_ontology_term_id,
               parent.source_id as parent_ontology_term_source_id
        from sres.OntologyRelationship orel, sres.OntologyTerm parent, sres.OntologyTerm child,
             sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
        where orel.subject_term_id = child.ontology_term_id
          and orel.object_term_id = parent.ontology_term_id
          and orel.subject_term_id != orel.object_term_id -- work around ICEMR bug
          and orel.object_term_id
              not in (select ontology_term_id from sres.OntologyTerm where lower(name) = 'thing')
          and orel.external_database_release_id = edr.external_database_release_id
          and (orel.predicate_term_id is null
               or orel.predicate_term_id
                  in (select ontology_term_id from sres.OntologyTerm where source_id = 'subClassOf'))
          and edr.external_database_id = ed.external_database_id
          and ed.name
              in (select hierarchy_dataset_name
                  from &prefixHierarchyMap)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index &prefixOrelIx&1
        on &prefixOntologyRelation&1 (hierarchy_dataset_name, child_ontology_term_id, parent_ontology_term_id)
        tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create unique index &prefixOrelUqIx&1
        on &prefixOntologyRelation&1 (hierarchy_dataset_name, child_ontology_term_id)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="OntologyAncestor" prefixEnabled="true">
   <comment>
     (term, ancestor term, ontology) 3-tuples
   </comment>
    <internalDependency name="OntologyRelation"/>
    <sql>
      <![CDATA[
        create table &prefixOntologyAncestor&1 nologging as
        select hierarchy_dataset_name, connect_by_root child_ontology_term_id as ontology_term_id,
               parent_ontology_term_id as ancestor_ontology_term_id
        from &prefixOntologyRelation
        start with (hierarchy_dataset_name, child_ontology_term_id)
                   in (select hierarchy_dataset_name, child_ontology_term_id
                       from &prefixOntologyRelation)
        connect by child_ontology_term_id = prior parent_ontology_term_id
                   and hierarchy_dataset_name = prior hierarchy_dataset_name
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create unique index &prefixontac&1_uqix
               on &prefixOntologyAncestor&1 (hierarchy_dataset_name, ontology_term_id, ancestor_ontology_term_id)
               tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="DatasetTerm" prefixEnabled="true">
   <comment></comment>
    <internalDependency name="HierarchyMap"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologySynonym"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
        create table &prefixDatasetTerm&1 nologging as
        select distinct ed.name as hierarchy_dataset_name, ot.ontology_term_id,
                        ot.source_id, syn.ontology_synonym as name,
                        syn.definition, cast(null as varchar(10)) as display_order, cast(null as varchar(10)) as variable
        from sres.OntologyTerm ot, sres.OntologySynonym syn,
             sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
        where ot.ontology_term_id = syn.ontology_term_id
          and syn.external_database_release_id = edr.external_database_release_id
          and edr.external_database_id = ed.external_database_id
          and ed.name
              in (select hierarchy_dataset_name
                  from &prefixHierarchyMap)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create unique index &prefixdt&1_uqix
               on &prefixDatasetTerm&1 (hierarchy_dataset_name, ontology_term_id)
               tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index &prefixdt&1_1ix
               on &prefixDatasetTerm&1 (hierarchy_dataset_name, ontology_term_id, source_id, name)
               tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <!-- renamed from ProtocolAppNodeRecord -->
  <tuningTable name="PANRecord" prefixEnabled="true">
   <comment>Input to pan meta data tables</comment>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="study.StudyLink"/>
    <externalDependency name="study.Study"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
        create table &prefixPanRecord&1 as
        select distinct pan.protocol_app_node_id as pan_id, pan.name as pan_name,
                        pan.isa_type as pan_isa_type, ot.name as pan_type,
                        ot.source_id as pan_type_source_id,
                        ot.ontology_term_id as pan_type_id
        from study.ProtocolAppNode pan, sres.OntologyTerm ot, study.StudyLink sl,
             study.Study s, sres.ExternalDatabase d, sres.ExternalDatabaseRelease r
        where ot.ontology_term_id = pan.type_id
          and pan.protocol_app_node_id = sl.protocol_app_node_id
          and sl.study_id = s.study_id
          and s.external_database_release_id = r.external_database_release_id
          and r.external_database_id = d.external_database_id
          and (ot.source_id
               in ('EUPATH_0000738', --Observation/Event
                   'PCO_0000024', -- Household
                   'EUPATH_0000096', --Participant
                   'EUPATH_0000327', -- CDC light trap
                   'EUPATH_0025169', -- Insect sample
                   'EUPATH_0035127', -- Community
                   'OBI_0100051','EUPATH_0000609' -- SPecimentype (need to replace with specimen)
                  )
               or pan.isa_type = 'Sample'
              )
          and (d.name = '&filterValue' or nvl('&filterValue', '0') = '0')
        order by pan.name
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="PANResults" prefixEnabled="true">
    <comment>Table of protocol app node ids and the name of the result table where they are referenced
    </comment>
    <internalDependency name="PANExtDbRls"/>
    <externalDependency name="apidb.ChrCopyNumber"/>
    <externalDependency name="apidb.CrisprPhenotype"/>
    <externalDependency name="apidb.GeneCopyNumber"/>
    <externalDependency name="apidb.IntronJunction"/>
    <externalDependency name="apidb.MassSpecSummary"/>
    <externalDependency name="apidb.RflpGenotype"/>
    <externalDependency name="apidb.RflpGenotypeNumber"/>
    <externalDependency name="results.CompoundMassSpec"/>
    <externalDependency name="results.EditingEvent"/>
    <externalDependency name="results.FamilyDiffResult"/>
    <externalDependency name="results.FamilyExpression"/>
    <externalDependency name="results.GeneDiffResult"/>
    <externalDependency name="results.GeneExpression"/>
    <externalDependency name="results.GeneSimilarity"/>
    <externalDependency name="results.LineageAbundance"/>
    <externalDependency name="results.NaFeatureDiffResult"/>
    <externalDependency name="results.NaFeatureExpression"/>
    <externalDependency name="results.NaFeatureHostResponse"/>
    <externalDependency name="results.ReporterDiffResult"/>
    <externalDependency name="results.ReporterExpression"/>
    <externalDependency name="results.ReporterIntensity"/>
    <externalDependency name="results.RnaDiffResult"/>
    <externalDependency name="results.RnaExpression"/>
    <externalDependency name="results.SegmentDiffResult"/>
    <externalDependency name="results.SegmentResult"/>
    <externalDependency name="results.SeqVariation"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <sql>
      <![CDATA[
    create table &prefixPANResults&1 as
    select distinct r.*
    from (
      select protocol_app_node_id as pan_id, 'Results::NAFeatureDiffResult' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.NAFeatureDiffResult)
    union
      select protocol_app_node_id, 'Results::ReporterIntensity' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.ReporterIntensity)
    union
      select protocol_app_node_id, 'Results::SegmentResult' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.SegmentResult)
    union
      select protocol_app_node_id, 'Results::CompoundMassSpec' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.CompoundMassSpec)
    union
      select protocol_app_node_id, 'Results::NaFeatureHostResponse' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.NaFeatureHostResponse)
    union
      select protocol_app_node_id, 'ApiDB::ChrCopyNumber' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from ApiDB.ChrCopyNumber)
    union
      select protocol_app_node_id, 'ApiDB::GeneCopyNumber' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from ApiDB.GeneCopyNumber)
    union
      select protocol_app_node_id, 'Results::NAFeatureExpression' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.NAFeatureExpression)
    union
      select protocol_app_node_id, 'Results::EditingEvent' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.EditingEvent)
    union
      select protocol_app_node_id, 'Results::FamilyDiffResult' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.FamilyDiffResult)
    union
      select protocol_app_node_id, 'Results::FamilyExpression' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.FamilyExpression)
    union
      select protocol_app_node_id, 'Results::GeneDiffResult' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.GeneDiffResult)
    union
      select protocol_app_node_id, 'Results::GeneExpression' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.GeneExpression)
    union
      select protocol_app_node_id, 'Results::GeneSimilarity' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.GeneSimilarity)
    union
      select protocol_app_node_id, 'Results::ReporterDiffResult' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.ReporterDiffResult)
    union
      select protocol_app_node_id, 'Results::ReporterExpression' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.ReporterExpression)
      union
    select protocol_app_node_id, 'Results::RnaDiffResult' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.RnaDiffResult)
      union
    select protocol_app_node_id, 'Results::RnaExpression' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.RnaExpression)
      union
    select protocol_app_node_id, 'Results::LineageAbundance' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.LineageAbundance)
    union
    select protocol_app_node_id, 'Results::SegmentDiffResult' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.SegmentDiffResult)
    union
      select protocol_app_node_id, 'Results::SeqVariation' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.SeqVariation)
    union
      select protocol_app_node_id, 'ApiDB::SequenceVariation' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from study.ProtocolAppNode where name like '% (Sequence Variation)')
    union
      select protocol_app_node_id, 'ApiDB::MassSpecSummary' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from apidb.MASSSPECSUMMARY)
    union
      select protocol_app_node_id, 'ApiDB::IntronJunction' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from apidb.IntronJunction)
    union
      select protocol_app_node_id, 'ApiDB::RflpGenotype' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from apidb.RflpGenotype)
    union
      select protocol_app_node_id, 'ApiDB::RflpGenotypeNumber' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from apidb.RflpGenotypeNumber)
    union
      select protocol_app_node_id, 'ApiDB::CrisprPhenotype' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from apidb.crisprphenotype)
    ) r, &prefixpanextdbrls panExtDbRls
    where r.pan_id = panExtDbRls.pan_id
      and (panExtDbRls.dataset_name = '&filterValue' or nvl('&filterValue', '0') = '0')
      ]]>
    </sql>
  </tuningTable>

   <!-- renamed from ProtocolAppNodeIO -->
  <tuningTable name="PANIO" prefixEnabled="true">
   <comment>ALL inputs and outputs</comment>
    <internalDependency name="PANExtDbRls"/>
    <externalDependency name="study.ProtocolApp"/>
    <externalDependency name="study.Input"/>
    <externalDependency name="study.Output"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <sql>
      <![CDATA[
        create table &prefixPANIO&1 nologging as
        select distinct io.*
        from (
        select i.protocol_app_node_id input_pan_id, pa.protocol_app_id,
               o.protocol_app_node_id output_pan_id,
               in_type.source_id as input_pan_type_source_id,
               --in_type.name as input_pan_type,
               in_type.ontology_term_id as input_pan_type_id,
               out_type.source_id as output_pan_type_source_id,
               --out_type.name as output_pan_type,
               out_type.ontology_term_id as output_pan_type_id
        from study.ProtocolApp pa, study.Input i, study.Output o,
             study.ProtocolAppNode in_pan, study.ProtocolAppNode out_pan,
             sres.OntologyTerm in_type,  sres.OntologyTerm out_type
        where i.protocol_app_id = pa.protocol_app_id
          and o.protocol_app_id = pa.protocol_app_id
          and i.protocol_app_node_id = in_pan.protocol_app_node_id
          and o.protocol_app_node_id = out_pan.protocol_app_node_id
          and in_pan.type_id = in_type.ontology_term_id(+)
          and out_pan.type_id = out_type.ontology_term_id(+)
          ) io, &prefixpanextdbrls panExtDbRls
      where io.input_pan_id = panExtDbRls.pan_id -- the input and outputs will have same dataset in prefix enabled mode only
        and (panExtDbRls.dataset_name = '&filterValue' or nvl('&filterValue', '0') = '0')
        order by io.input_pan_id, io.output_pan_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index &prefixpainio2_iix&1 on &prefixPANIO&1
               (input_pan_id, output_pan_id, protocol_app_id, input_pan_type_source_id, output_pan_type_source_id)
               tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index &prefixpainio2_oix&1 on &prefixPANIO&1
               (output_pan_id, input_pan_id, protocol_app_id, input_pan_type_source_id, output_pan_type_source_id)
               tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index &prefixpainio2_otypeix&1 on &prefixPANIO&1
               (output_pan_type_source_id, input_pan_type_source_id, output_pan_id, input_pan_id, protocol_app_id)
               tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index &prefixpainio2_itypeix&1 on &prefixPANIO&1
               (input_pan_type_source_id, output_pan_type_source_id, input_pan_id, output_pan_id, protocol_app_id)
               tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="HierarchyMap" prefixEnabled="true">
    <comment>Maps each dataset name to the name of the external database to use for ontology synonyms and relationships
    </comment>
    <internalDependency name="DatasetPresenter"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="study.Study"/>
    <sql>
      <![CDATA[
        create table &prefixHierarchyMap&1 nologging as
        select datasets.dataset_name,
               nvl(dynamic_mapping.hierarchy, hardwired_hierarchy) as hierarchy_dataset_name
        from (select name as dataset_name,
                     case
                       when lower(name) like '%microarrayantibody%'
                            and name not like '%Helb_RecentExposure%'
                         then 'Ontology_icemr_RSRC'
                       when lower(name) like 'otu%'
                         then 'OntologyTerm_microbiome_RSRC'
                       else 'OntologyTerm_eupath_isa_RSRC'
                     end as hardwired_hierarchy
              from sres.ExternalDatabase
              where external_database_id
                    in (select edr.external_database_id
                        from sres.ExternalDatabaseRelease edr, study.Study s
                        where s.external_database_release_id = edr.external_database_release_id)
                and (name = '&filterValue' or nvl('&filterValue', '0') = '0')
             ) datasets,
             (select dsp.name as dataset_name, d.name as hierarchy
              from DatasetPresenter dsp, DatasetProperty p, sres.ExternalDatabase d
               where p.property = 'webDisplayOntologyName'
                and dsp.dataset_presenter_id = p.dataset_presenter_id
                and 'OntologyTerm_' || p.value || '_RSRC' = d.name
             ) dynamic_mapping
        where datasets.dataset_name = dynamic_mapping.dataset_name(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index &prefixhmap_ix0&1
        on &prefixHierarchyMap&1 (dataset_name, hierarchy_dataset_name)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>

   <!-- renamed from PANExternalDatabaseRelease -->
  <tuningTable name="PANExtDbRls" prefixEnabled="true">
   <comment>ALL inputs and outputs</comment>
    <externalDependency name="study.Study"/>
    <externalDependency name="study.StudyLink"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
 create table &prefixPANExtDbRls&1 nologging as
select distinct protocol_app_node_id as pan_id, external_database_release_id, name as dataset_name
from (
SELECT
  sl.protocol_app_node_id
, s.external_database_release_id
, d.name
FROM
  study.study s
, study.studylink sl
, sres.externaldatabaserelease r
, sres.externaldatabase d
WHERE
  s.external_database_release_id = r.external_database_release_id
  and r.external_database_id = d.external_database_id
  and s.study_id = sl.study_id
  and s.external_database_release_id is not null
UNION
select pan.protocol_app_node_id
, pan.external_database_release_id
, d.name
from study.protocolappnode pan
, sres.externaldatabaserelease r
, sres.externaldatabase d
WHERE
  pan.external_database_release_id = r.external_database_release_id
  and r.external_database_id = d.external_database_id
  and pan.external_database_release_id is not null
)
WHERE (name = '&filterValue' or nvl('&filterValue', '0') = '0')
ORDER BY external_database_release_id, protocol_app_node_id
      ]]>
    </sql>
  </tuningTable>

  <!-- Renamed from PANProtocolMetadata -->
  <tuningTable name="InferredParams" prefixEnabled="true">
    <comment>
    </comment>
    <internalDependency name="DatasetTerm"/>
    <internalDependency name="HierarchyMap"/>
    <internalDependency name="PANIO"/>
    <internalDependency name="PANResults"/>
    <internalDependency name="SampleId"/>
    <internalDependency name="PANRecord"/>
    <externalDependency name="study.Output"/>
    <externalDependency name="apidb.Datasource"/>
    <externalDependency name="study.Study"/>
    <externalDependency name="study.StudyLink"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="study.ProtocolApp"/>
    <externalDependency name="study.Input"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.Characteristic"/>
    <externalDependency name="study.Protocol"/>
    <externalDependency name="study.ProtocolParam"/>
    <externalDependency name="study.ProtocolAppParam"/>
    <ancillaryTable name="ValueCaps"/>
    <ancillaryTable name="InferredChars"/> <!-- renamed from PANCHaracteristicMetadata -->
    <ancillaryTable name="SampleProcess"/> <!-- renamed from SampleDownstream -->
    <ancillaryTable name="PANUpstream"/>
    <sql>
      <![CDATA[
        create table &prefixPANUpstream&1 nologging as
        select *
        from (  select connect_by_root output_pan_id as pan_id, input_pan_id as input_pan_id, protocol_app_id
                from &prefixPanio
                start with output_pan_id
                           in (  select pan_id
                                 from &prefixPANResults
                               union
                                 select pan_id
                                 from &prefixSampleId
                                 where project_id not in ('ClinEpiDB')
                               union
                                 select protocol_app_node_id
                                 from study.ProtocolAppNode
                                 where isa_type in ('Phenotype','Genotype')
                              )
                connect by prior input_pan_id = output_pan_id
              union
                select si.pan_id, si.pan_id as input_node_id, o.protocol_app_id
                from &prefixSampleId si, study.Output o
                where si.pan_id = o.protocol_app_node_id(+)
              union
                select panr.pan_id, panr.pan_id as input_pan_id, o.protocol_app_id
                from &prefixPANRecord panr, study.Output o
                where panr.pan_type != 'specimen'
                  and panr.pan_id = o.protocol_app_node_id(+)
              union
                select c.protocol_app_node_id, c.protocol_app_node_id, o.protocol_app_id
                from study.Characteristic c, study.Output o
                where c.protocol_app_node_id = o.protocol_app_node_id(+)
             )
        where pan_id
              not in (select pan.protocol_app_node_id
                      from study.ProtocolAppNode pan, sres.ExternalDatabase ed,
                           sres.ExternalDatabaseRelease edr
                      where pan.external_database_release_id = edr.external_database_release_id
                        and edr.external_database_id = ed.external_database_id
                        and ed.name like '%_isolates_genbank_RSRC')
        order by pan_id, protocol_app_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index &prefixpanup_pix&1 on &prefixPANUpstream&1 (pan_id, input_pan_id, protocol_app_id)
             tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index &prefixpanup_iix&1 on &prefixPANUpstream&1 (input_pan_id, pan_id, protocol_app_id)
             tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create table &prefixInferredParams&1 nologging as
        with param_term
             as (select pp.protocol_param_id, ot.ontology_term_id, ot.source_id,
                 -- use row_number() to get only the oldest of terms that share a name
                 row_number()
                   over (partition by ot.name order by ot.ontology_term_id)
                   as ranking
                 from study.ProtocolParam pp, sres.OntologyTerm ot
                 where ot.name = pp.name
                )
        select distinct node_inputs.pan_id, ot.name as pan_type,
               ot.ontology_term_id as pan_type_id,
               pan.isa_type as pan_isa_type, ds.name as dataset_name,
               p.name as protocol, proto_type.name as protocol_type, p.protocol_type_id,
               pan.name as pan_name, pp.name as property,
               param_term.ontology_term_id as property_id,
               param_term.source_id as property_source_id,
               pap.value, pap.protocol_app_param_id, ds.type as dataset_type, ds.subtype as dataset_subtype, tn.name as organism,
               pp.unit_type_id as unit_id,
               nvl(mt.name, 'assay') as ancestor_pan_type,
               mt.ontology_term_id as ancestor_pan_type_id
        from &prefixPANUpstream&1 node_inputs, param_term, study.ProtocolAppParam pap, sres.ontologyterm ot,
             study.ProtocolParam pp, study.Protocol p, study.StudyLink sl,
             sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
             apidb.Datasource ds, study.ProtocolAppNode pan, sres.TaxonName tn, sres.ontologyterm proto_type,
             sres.OntologyTerm mt,
             (  select s.study_id, i.external_database_release_id
                from study.Study s, study.Study i
                where s.investigation_id = i.study_id
              union
                select s.study_id, s.external_database_release_id
                from study.Study s) study_release
        where node_inputs.protocol_app_id = pap.protocol_app_id
          and pap.protocol_param_id = pp.protocol_param_id
          and pp.protocol_id = p.protocol_id
          and node_inputs.pan_id = sl.protocol_app_node_id
          and sl.study_id = study_release.study_id
          and study_release.external_database_release_id = edr.external_database_release_id
          and edr.external_database_id = ed.external_database_id
          and ed.name = ds.name
          and (ed.name = '&filterValue' or nvl('&filterValue', '0') = '0')
          and node_inputs.pan_id = pan.protocol_app_node_id
          and pan.type_id = ot.ontology_term_id (+)
          and ds.taxon_id = tn.taxon_id(+)
          and (tn.name_class = 'scientific name' or tn.name_class is null)
          and p.name not like '%::%' -- avoid Perl class names
          and p.name not like '%data transformation' -- avoid data transformation protocol parameters
          and p.protocol_type_id = proto_type.ontology_term_id
          and pp.protocol_param_id = param_term.protocol_param_id
          and param_term.ranking = 1
          and pan.type_id = mt.ontology_term_id(+)
        order by organism, type, subtype, pan_name
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update &prefixInferredParams&1 ip
        set property
            = (select dt.name
               from &prefixHierarchyMap hm, &prefixDatasetTerm dt
               where hm.hierarchy_dataset_name = dt.hierarchy_dataset_name
                 and dt.ontology_term_id = ip.property_id
                 and hm.dataset_name = ip.dataset_name)
        where property_id
              in (select dt.ontology_term_id
                  from &prefixHierarchyMap hm, &prefixDatasetTerm dt
                  where hm.hierarchy_dataset_name = dt.hierarchy_dataset_name
                    and hm.dataset_name = ip.dataset_name)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update &prefixInferredParams&1 ip
        set pan_type
            = (select dt.name
               from &prefixHierarchyMap hm, &prefixDatasetTerm dt
               where hm.hierarchy_dataset_name = dt.hierarchy_dataset_name
                 and dt.ontology_term_id = ip.pan_type_id
                 and hm.dataset_name = ip.dataset_name)
        where pan_type_id
              in (select dt.ontology_term_id
                  from &prefixHierarchyMap hm, &prefixDatasetTerm dt
                  where hm.hierarchy_dataset_name = dt.hierarchy_dataset_name
                    and hm.dataset_name = ip.dataset_name)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create table &prefixValueCaps&1 nologging as
        select qualifier_id, lower_value, commonest_capitalization
        from (select qualifier_id,
                     cast(value as varchar2(3100)) as commonest_capitalization,
                     cast(lower(value) as varchar2(3100)) as lower_value,
                     dense_rank() over (partition by qualifier_id, lower(value) order by count(*) desc) as ranking
              from study.Characteristic c, study.StudyLink sl, study.Study s,
                   sres.ExternalDatabase d, sres.ExternalDatabaseRelease r
              where c.protocol_app_node_id = sl.protocol_app_node_id
                and sl.study_id = s.study_id
                and s.external_database_release_id = r.external_database_release_id
                and r.external_database_id = d.external_database_id
                and (d.name = '&filterValue' or nvl('&filterValue', '0') = '0')
              group by qualifier_id, value
             )
        where ranking = 1
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index &prefixvalcap_ix&1
               on &prefixValueCaps&1 (qualifier_id, lower_value, commonest_capitalization)
               tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create table &prefixInferredChars&1 nologging as
        select -- distinct -- should be unneeded and can use too much temp space
                sample_pan.protocol_app_node_id as pan_id,
                        sample_ot.name as pan_type,
                        sample_ot.ontology_term_id as pan_type_id,
                        sample_pan.isa_type as pan_isa_type,
                   --   pan.protocol_app_node_id as ancestor_pan_id,
                        nvl(mt.name, 'assay') as ancestor_pan_type,
                        mt.ontology_term_id as ancestor_pan_type_id,
                       CASE 
                         WHEN attribute_term.source_id = 'EUPATH_0000455'
                           -- this term should be replaced by OBI_0003056
                         THEN 'Average mapping coverage'
                         ELSE attribute_term.name
                        END AS property, -- if not a material type it has to be an assay
                        attribute_term.ontology_term_id as property_id,
                        attribute_term.source_id as property_source_id,
                        nvl(value_term.name, caps.commonest_capitalization) as value,
                        value_term.ontology_term_id as value_id, c.characteristic_id,
                        ds.name as dataset_name, hm.hierarchy_dataset_name,
                        sample_pan.name as pan_name, ds.type as dataset_type,
                        ds.subtype as dataset_subtype, tn.name as organism, c.unit_id
                 from &prefixPANUpstream&1 node_inputs, study.ProtocolAppNode pan, &prefixValueCaps&1 caps,
                      sres.OntologyTerm value_term, sres.OntologyTerm mt,
                      sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
                      sres.OntologyTerm attribute_term, apidb.Datasource ds, sres.TaxonName tn,
                      study.ProtocolAppNode sample_pan, sres.OntologyTerm sample_ot,
                      &prefixHierarchyMap hm,
                      (select min(characteristic_id) as characteristic_id,
                              protocol_app_node_id, ontology_term_id, qualifier_id, unit_id, value
                       from study.Characteristic
                       group by protocol_app_node_id, ontology_term_id, qualifier_id, unit_id, value
                      ) c,
                      (select distinct sl.protocol_app_node_id, study_release.external_database_release_id
                       from study.StudyLink sl,
                            (  select s.study_id, i.external_database_release_id
                               from study.Study s, study.Study i
                               where s.investigation_id = i.study_id
                             union
                               select s.study_id, s.external_database_release_id
                               from study.Study s) study_release
                       where sl.study_id = study_release.study_id) pan_release
                 where pan.protocol_app_node_id = c.protocol_app_node_id
                   and pan.type_id = mt.ontology_term_id (+)
                   and c.ontology_term_id = value_term.ontology_term_id(+)
                   and c.qualifier_id = caps.qualifier_id(+)
                   and lower(c.value) = caps.lower_value(+)
                   and c.qualifier_id = attribute_term.ontology_term_id(+)
                   and node_inputs.input_pan_id = pan.protocol_app_node_id
                   and node_inputs.pan_id = pan_release.protocol_app_node_id
                   and pan_release.external_database_release_id = edr.external_database_release_id
                   and edr.external_database_id = ed.external_database_id
                   and ed.name = ds.name
                   and (ed.name = '&filterValue' or nvl('&filterValue', '0') = '0')
                   and node_inputs.pan_id = sample_pan.protocol_app_node_id
                   and sample_pan.type_id = sample_ot.ontology_term_id (+)
                   and ds.taxon_id = tn.taxon_id(+)
                   and (tn.name_class = 'scientific name' or tn.name_class is null)
                -- temporary may need adjusting for RNASeq
                   and (pan.type_id is not null
                        or attribute_term.source_id
                           in ('GENEPIO_0000092', -- average mapping coverage
                               'EUPATH_0000455'  -- proportion mapped reads
                              )
                       )
                   and ds.name = hm.dataset_name
--                   and ds.name != 'ISASimple_RSRC'
--                   and ds.name != 'ISA_RSRC'
--                 order by organism, type, subtype, pan_name
      ]]>
    </sql>

<!--
    <sql>
      <![CDATA[
        create unique index &prefixpanchar_uqix&1
             on &prefixInferredChars&1 (dataset_name, pan_id, property, property_source_id, value)
             tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index &prefixpanchar_ix&1 on &prefixInferredChars&1 (dataset_name, dataset_type, dataset_subtype, pan_id, pan_name, property, value)
             tablespace indx
      ]]>
    </sql>
-->

    <sql>
      <![CDATA[
        update &prefixInferredChars&1 ic
        set property
            = (select dt.name
               from &prefixHierarchyMap hm, &prefixDatasetTerm dt
               where hm.hierarchy_dataset_name = dt.hierarchy_dataset_name
                 and dt.ontology_term_id = ic.property_id
                 and hm.dataset_name = ic.dataset_name)
        where property_id
              in (select dt.ontology_term_id
                  from &prefixHierarchyMap hm, &prefixDatasetTerm dt
                  where hm.hierarchy_dataset_name = dt.hierarchy_dataset_name
                    and hm.dataset_name = ic.dataset_name)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update &prefixInferredChars&1 ic
        set value
            = (select dt.name
               from &prefixHierarchyMap hm, &prefixDatasetTerm dt
               where hm.hierarchy_dataset_name = dt.hierarchy_dataset_name
                 and dt.ontology_term_id = ic.value_id
                 and hm.dataset_name = ic.dataset_name)
        where value_id
              in (select dt.ontology_term_id
                  from &prefixHierarchyMap hm, &prefixDatasetTerm dt
                  where hm.hierarchy_dataset_name = dt.hierarchy_dataset_name
                    and hm.dataset_name = ic.dataset_name)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update &prefixInferredChars&1 ic
        set pan_type
            = (select dt.name
               from &prefixHierarchyMap hm, &prefixDatasetTerm dt
               where hm.hierarchy_dataset_name = dt.hierarchy_dataset_name
                 and dt.ontology_term_id = ic.pan_type_id
                 and hm.dataset_name = ic.dataset_name)
        where pan_type_id
              in (select dt.ontology_term_id
                  from &prefixHierarchyMap hm, &prefixDatasetTerm dt
                  where hm.hierarchy_dataset_name = dt.hierarchy_dataset_name
                    and hm.dataset_name = ic.dataset_name)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update &prefixInferredChars&1 ic
        set ancestor_pan_type
            = (select dt.name
               from &prefixHierarchyMap hm, &prefixDatasetTerm dt
               where hm.hierarchy_dataset_name = dt.hierarchy_dataset_name
                 and dt.ontology_term_id = ic.ancestor_pan_type_id
                 and hm.dataset_name = ic.dataset_name)
        where ancestor_pan_type_id
              in (select dt.ontology_term_id
                  from &prefixHierarchyMap hm, &prefixDatasetTerm dt
                  where hm.hierarchy_dataset_name = dt.hierarchy_dataset_name
                    and hm.dataset_name = ic.dataset_name)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index &prefixpancharorg_ix&1 on &prefixInferredChars&1 (organism, dataset_type, dataset_subtype, dataset_name, pan_id, pan_name, property, value)
             tablespace indx
      ]]>
    </sql>

    <sql>
      <![CDATA[
create table &prefixSampleProcess&1 nologging as
SELECT
  p1.name
, p1.protocol_app_node_id
, p3.name as input_name
, p3.protocol_app_node_id as input_pan_id
, case
    WHEN ot3.name LIKE 'data%'
    THEN 'Data'
    else p3.isa_type
  end as input_isa_type
, ot3.name as input_material_type
, p.name AS protocol
, p2.name AS output_name
, p2.protocol_app_node_id AS output_pan_id
, case
    WHEN ot2.name LIKE 'data%'
    THEN 'Data'
    else p2.isa_type
  end as output_isa_type
, ot2.name AS output_material_type
FROM
  (SELECT
    connect_by_root input_pan_id AS pan_id
  , input_pan_id
  , output_pan_id
  , protocol_app_id
  from
    &prefixpanio
    start with input_pan_id in (SELECT pan_id FROM &prefixSampleId)
    CONNECT BY prior output_pan_id = input_pan_id
  ) io
, study.protocolappnode p1
, study.protocolappnode p2
, study.protocolappnode p3
, sres.ontologyterm ot2
, sres.ontologyterm ot3
, study.protocol p
, study.protocolapp pa
WHERE
  io.pan_id = p1.protocol_app_node_id
  and io.output_pan_id = p2.protocol_app_node_id
  and io.input_pan_id = p3.protocol_app_node_id
  and p2.type_id = ot2.ontology_term_id (+)
  and p3.type_id = ot3.ontology_term_id (+)
  and io.protocol_app_id = pa.protocol_app_id
  and pa.protocol_id = p.protocol_id
ORDER BY name, p1.protocol_app_node_id, input_pan_id, output_pan_id
      ]]>
    </sql>
  </tuningTable>

  <!-- renamed from PANParameterValues -->
  <tuningTable name="PANParamValues" prefixEnabled="true">
    <comment>
    </comment>
    <internalDependency name="PANIO"/>
    <externalDependency name="study.Protocol"/>
    <externalDependency name="study.ProtocolParam"/>
    <externalDependency name="study.ProtocolAppParam"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <sql>
      <![CDATA[
        create table &prefixPANParamValues&1 nologging as
select
  p.name as protocol
, pp.name as protocol_param
, pap.value as protocol_param_value
, pan.name as protocol_app_node_name
, pan.protocol_app_node_id
FROM
  study.protocolappparam pap
, study.protocolparam pp
, study.protocol p
, &prefixpanio io
, study.protocolappnode pan
WHERE
  pp.protocol_param_id = pap.protocol_param_id
  AND p.protocol_id = pp.protocol_id
  AND io.protocol_app_id = pap.protocol_app_id
  AND io.output_pan_id = pan.protocol_app_node_id
ORDER BY protocol_app_node_name
      ]]>
    </sql>
  </tuningTable>

  <!--Renamed from FallbackMetadata -->
  <tuningTable name="DefaultChars" prefixEnabled="true">
    <comment>
      For datasets that have results but no metadata, a fallback set of metadata comprising the name of each ProtocolAppNode
    </comment>
    <internalDependency name="DatasetTerm"/>
    <internalDependency name="PANResults"/>
    <internalDependency name="DatasetPresenter"/>
    <externalDependency name="apidb.Datasource"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.Study"/>
    <externalDependency name="study.StudyLink"/>
    <sql>
      <![CDATA[
        create table &prefixDefaultChars&1 nologging as
        -- regular query for most datasets
        select ed.name as dataset_name
        , ds.type as dataset_type
        , CASE WHEN ds.type = 'genome'
            THEN 'HTS_SNP'
            ELSE ds.subtype
            END as dataset_subtype
        , tn.name as organism
        , CASE WHEN ds.type = 'genome' THEN o.strain_abbrev ELSE pan.name END AS pan_name
        , pan.protocol_app_node_id as pan_id
        , pan.isa_type as pan_isa_type
        , nvl(ot.name, 'dataset') as property
        , ot.source_id AS property_source_id
        , ot.ontology_term_id AS property_id
        , study_release.name as study_name
        , CASE
            WHEN ds.type = 'genome'
              THEN tn.name || ' ' || dsp.display_name
            WHEN dsp.display_name IS NULL
              THEN replace(replace(replace(replace(ed.name, 'pfal3D7_microarrayAntibody_', ''),
                                           '_ICEMR_RSRC', ''),
                                   '_RSRC', ''),
                           '_', ' ')
            ELSE dsp.display_name
          END as value,
          nvl(mt.name, 'assay') as ancestor_pan_type,
          mt.ontology_term_id as ancestor_pan_type_id
        from study.ProtocolAppNode pan, apidb.Datasource ds, study.StudyLink sl,
             sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
             sres.TaxonName tn, apidbTuning.DatasetPresenter dsp, apidb.organism o,
             sres.OntologyTerm mt,
             (  select s.study_id, i.external_database_release_id, i.name
                from study.Study s, study.Study i
                where s.investigation_id = i.study_id
              union
                select s.study_id, s.external_database_release_id, s.name
                from study.Study s) study_release,
             (select max(ontology_term_id) as ontology_term_id,
                     max(source_id) as source_id, max(name) as name
              from sres.OntologyTerm
              where source_id = 'IAO_0000100' -- "data set"
             ) ot
        where pan.protocol_app_node_id in (select pan_id
                                           from &prefixPANResults)
          and pan.protocol_app_node_id = sl.protocol_app_node_id
          and sl.study_id = study_release.study_id
          and study_release.external_database_release_id = edr.external_database_release_id
          and edr.external_database_id = ed.external_database_id
          and ed.name = replace(ds.name, 'primary_genome_RSRC', 'NGS_SNPsAndVariations')
          and ds.taxon_id = tn.taxon_id(+)
          and ds.taxon_id = o.taxon_id(+)
          --cnv datasets use hts_snp presenters
          and replace(ds.name, 'copyNumberVariations', 'HTS_SNP') = dsp.name (+)
          and (tn.name_class = 'scientific name' or tn.name_class is null)
          and (ed.name = '&filterValue' or nvl('&filterValue', '0') = '0')
          and pan.type_id = mt.ontology_term_id(+)
UNION ALL
        -- special query for reference strain
        select ed.name as dataset_name, 'SNP' as dataset_type, 'HTS_SNP' as dataset_subtype,
               tn.name as organism, o.strain_abbrev as pan_name, pan.protocol_app_node_id as pan_id,
               pan.isa_type as pan_isa_type,
               ot.name as property,
               ot.source_id as property_source_id,
               ot.ontology_term_id as property_id,
               study_release.name as study_name, tn.name as value,
               nvl(mt.name, 'assay') as ancestor_pan_type,
               mt.ontology_term_id as ancestor_pan_type_id
        from study.ProtocolAppNode pan, study.StudyLink sl, sres.OntologyTerm ot,
             sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
             sres.TaxonName tn, apidb.Organism o, sres.OntologyTerm mt,
             (  select s.study_id, i.external_database_release_id, i.name
                from study.Study s, study.Study i
                where s.investigation_id = i.study_id
              union
                select s.study_id, s.external_database_release_id, s.name
                from study.Study s) study_release
        where pan.protocol_app_node_id in (select pan_id
                                           from &prefixPANResults)
          and pan.protocol_app_node_id = sl.protocol_app_node_id
          and sl.study_id = study_release.study_id
          and study_release.external_database_release_id = edr.external_database_release_id
          and edr.external_database_id = ed.external_database_id
          and ed.name like '%_NGS_SNPsAndVariations'
          and o.abbrev = replace(ed.name, '_NGS_SNPsAndVariations', '')
          and o.taxon_id = tn.taxon_id(+)
          and (tn.name_class = 'scientific name' or tn.name_class is null)
          and (ed.name = '&filterValue' or nvl('&filterValue', '0') = '0')
          and ot.source_id
              = case
                  -- is this a FungiDB instance?
                  when lower(substr(sys_context ('USERENV', 'SERVICE_NAME'), 1, 4)) = 'fung'
                    then 'NCIT_C14209' -- "Fungal organism"
                  else 'OPL_0000232' -- "parasite organism"
                end
          and pan.type_id = mt.ontology_term_id(+)
        order by organism, dataset_name, pan_name
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update &prefixDefaultChars&1 dc
        set property
            = (select dt.name
               from &prefixHierarchyMap hm, &prefixDatasetTerm dt
               where hm.hierarchy_dataset_name = dt.hierarchy_dataset_name
                 and dt.ontology_term_id = dc.property_id
                 and hm.dataset_name = dc.dataset_name)
        where property_id
              in (select dt.ontology_term_id
                  from &prefixHierarchyMap hm, &prefixDatasetTerm dt
                  where hm.hierarchy_dataset_name = dt.hierarchy_dataset_name
                    and hm.dataset_name = dc.dataset_name)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update &prefixDefaultChars&1 dc
        set property_source_id = property
        where property_source_id is null
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="DatasetLeafTerm" prefixEnabled="true">
    <comment>
      Ontology terms used in each dataset as properties that have values
    </comment>
    <internalDependency name="DefaultChars"/>
    <internalDependency name="InferredParams"/>
    <sql>
      <![CDATA[
        create table &prefixDatasetLeafTerm&1 nologging as
          select dataset_name, unit_id, property_id
          from &prefixInferredParams
        union
          select dataset_name, unit_id, property_id
          from &prefixInferredChars
        union
          select dataset_name, null, property_id
          from &prefixDefaultChars
        order by dataset_name, property_id
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="MetadataSummary" prefixEnabled="true">
    <comment>
      Summary stats for property values
    </comment>
    <internalDependency name="PropertyType"/>
    <internalDependency name="Metadata"/>
    <sql>
      <![CDATA[
	create table &prefixMetadataSummary&1 as
 	select s.property_source_id, s.distinct_values, pt.distinct_values as number_distinct_values,
               null as min, null as max, null as average, null as upper_quartile, null as lower_quartile
 	from (
  	  select property_source_id,
                 cast (substr(xmlagg(xmlelement(e, string_value,'|').extract('//text()') order by string_value).GetClobVal(), 1, 3990) as varchar2(4000))
                   as distinct_values
  	  from (
		select distinct m.property_source_id, m.string_value    
    		from &prefixmetadata m,
         	     &prefixpropertytype pt
    		where m.string_value is not null
    		and m.property_source_id = pt.property_source_id
    		and pt.type = 'string'
--    		and pt.distinct_values < 80
  		)
  	group by property_source_id
 	) s,
 	&prefixpropertytype pt
 	where pt.property_source_id = s.property_source_id
	union
 	select n.property_source_id, null as distinct_values, pt.distinct_values as number_distinct_values,
        	min, max, average, upper_quartile, lower_quartile
 	from (
   	  select m.property_source_id, 
          	cast(min(m.number_value) as varchar2(100)) as min, 
          	cast(max(m.number_value) as varchar2(100)) as max,
          	cast(avg(m.number_value) as varchar2(100)) as average,
          	cast(percentile_disc(.75) within group (order by m.number_value) as varchar2(100)) as upper_quartile,
          	cast(percentile_disc(.25) within group (order by m.number_value) as varchar2(100)) as lower_quartile
    	  from &prefixmetadata m,
         	&prefixpropertytype pt
    	  where m.number_value is not null
    	  and m.property_source_id = pt.property_source_id
    	  and pt.type = 'number'
    	  group by m.property_source_id
	) n,
 	&prefixpropertytype pt
	where pt.property_source_id = n.property_source_id  
	union
	select d.property_source_id, null as distinct_values, pt.distinct_values as number_distinct_values,
        	min, max, null as average, upper_quartile, lower_quartile
 	from (
     	  select m.property_source_id, 
              cast(to_char(min(m.date_value),'YYYY-MM-DD') AS varchar2(100)) as min,                                           
              cast(to_char(max(m.date_value),'YYYY-MM-DD') AS varchar2(100)) as max,                                           
              cast(to_char(percentile_disc(.75) within group (order by m.date_value),'YYYY-MM-DD') as varchar2(100)) as upper_quartile,
              cast(to_char(percentile_disc(.25) within group (order by m.date_value),'YYYY-MM-DD') as varchar2(100)) as lower_quartile

     	  from &prefixmetadata m,
          	&prefixpropertytype pt
     	  where m.date_value is not null
     	  and m.property_source_id = pt.property_source_id
     	  and pt.type = 'date'
     	  group by m.property_source_id
 	) d,
 	&prefixpropertytype pt
 	where pt.property_source_id = d.property_source_id
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="PropertyCategory" prefixEnabled="true">
    <comment>
      Category (or categories) of each property
    </comment>
    <internalDependency name="Metadata"/>
    <sql>
      <![CDATA[
	create table &prefixPropertyCategory&1 as
 	select distinct property_source_id, dataset_name, category
 	from &prefixMetadata
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index &prefixpcat_ixone&1
        on &prefixPropertyCategory&1 (property_source_id, dataset_name, category)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="Metadata" prefixEnabled="true">
    <comment>
      Metadata table for new, wide, strongly-typed filter param
    </comment>
    <internalDependency name="DefaultChars"/>
    <internalDependency name="PropertyType"/>
    <internalDependency name="InferredParams"/>
    <sql>
      <![CDATA[
        create table &prefixMetadata&1 nologging as
        select m.dataset_type, m.dataset_subtype, m.organism, m.dataset_name,
               m.pan_id, m.pan_name, m.pan_isa_type,
               m.category, m.property, m.property_id, mt.property_source_id,
               substr(m.value, 1, 250) as string_value,
               case
                 when m.value = lower(m.value)
                      and upper(substr(m.value, 1, 1)) || substr(m.value, 2) != value
                 then 1
                 else 0
               end as capitalization_flag,
               case when mt.type = 'number'
                      then apidb.parse_and_round_number(m.value)
                    else cast(null as number)
               end as number_value,
               case when mt.type = 'date' then apidb.parse_date(m.value) else cast(null as date) end as date_value
        from &prefixPropertyType mt,
             (  select dataset_type, dataset_subtype, organism, dataset_name,
                       pan_id, pan_name, pan_isa_type,
                       protocol as category, property, property_id, value
                from &prefixInferredParams
              union all
                select dataset_type, dataset_subtype, organism, dataset_name,
                       pan_id, pan_name, pan_isa_type,
                       ancestor_pan_type as category, property, property_id, value
                from &prefixInferredChars
              union all
                select dataset_type, dataset_subtype, organism, dataset_name,
                       pan_id, pan_name, pan_isa_type,
                       null as category, property, property_id, value
                from &prefixDefaultChars
             ) m
        where (m.property_id = mt.property_id
               or (mt.property_id is null and m.property = mt.property))
        -- order by organism, dataset_type, dataset_subtype, dataset_name, pan_name
      ]]>
    </sql>
    <sql>
      <![CDATA[
        insert into &prefixMetadata&1
        (dataset_type, dataset_subtype, organism, dataset_name, pan_id,
         pan_name, pan_isa_type, category, property, property_id,
         property_source_id, string_value)
        select *
        from (with sample_term
                   as (select max(ontology_term_id) as ontology_term_id,
                              max(source_id) as source_id,
                              max(name) as name
                       from sres.OntologyTerm
                       where source_id = 'NCIT_C42614')
              select distinct m.dataset_type, m.dataset_subtype, m.organism, m.dataset_name, m.pan_id,
                     m.pan_name, m.pan_isa_type, m.category,
                     nvl(st.name, 'Sample name') as property,
                     st.ontology_term_id as property_id,
                     st.source_id as property_source_id,
                     replace(m.pan_name, ' (Sequence Variation)', '') as string_value
              from &prefixMetadata&1 m, sample_term st
              where dataset_name
                    in ('cposSilveira_NGS_SNPsAndVariations',
                        'cposSilveira_HTS_SNP_Whole_Population_Genome_SNP_RSRC')
                and pan_name not like '%(DNA Sequencing)'
                and dataset_type != 'genome'
                and category is null
             )
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index &prefixmwn_ixone&1
        on &prefixMetadata&1 (property_source_id, pan_id, dataset_name, category, string_value, number_value, date_value)
        tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index &prefixmwn_ixtwo&1
        on &prefixMetadata&1 (category, property_source_id, pan_id, string_value, number_value, date_value)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="Ontology" prefixEnabled="true">
    <comment>
    </comment>
    <internalDependency name="DatasetTerm"/>
    <internalDependency name="DatasetLeafTerm"/>
    <internalDependency name="DefaultChars"/>
    <internalDependency name="HierarchyMap"/>
    <internalDependency name="InferredParams"/>
    <internalDependency name="OntologyAncestor"/>
    <internalDependency name="OntologyRelation"/>
    <internalDependency name="PropertyType"/>
    <sql>
      <![CDATA[
        create table &prefixOntology&1 nologging as
        with DatasetOntologyTerm
             -- a term (leaf or ancestor) of a dataset
             as (  -- ontology terms used as properties (things with values)
                   select dataset_name, property_id as ontology_term_id, unit_id
                   from &prefixDatasetLeafTerm
                 union
                   -- ontology terms with descendants used as properties
                   select leaf.dataset_name, ancestor.ancestor_ontology_term_id as ontology_term_id,
                   cast(null as number) as unit_id
                   from &prefixDatasetLeafTerm leaf, &prefixHierarchyMap hmap, &prefixOntologyAncestor ancestor
                   where leaf.property_id = ancestor.ontology_term_id
                     and leaf.dataset_name = hmap.dataset_name
                     and hmap.hierarchy_dataset_name = ancestor.hierarchy_dataset_name),
             DatasetOntologyVars
             as (
                   select ontology_term_id,apidb.tab_to_string(set(cast(COLLECT(distinct name) AS apidb.varchartab)), ', ') as variable_name from
                   (
                     select ontology_term_id, regexp_replace(substr(variable, instr(variable, ',', 1, lvl) + 1, instr(variable, ',', 1, lvl + 1) - instr(variable, ',', 1, lvl) - 1),'\w+::','') name 
                     from
                      ( select ',' || variable || ',' as variable, ontology_term_id from &prefixDatasetTerm ),
                      ( select level as lvl from dual connect by level <= 100 )
                     where lvl <= length(variable) - length(replace(variable, ',')) - 1
                     ) 
                     group by ontology_term_id
              ),
             DatasetInfo
             -- columns that are functions of dataset
             as (select dataset_name, max(dataset_type) as dataset_type,
                        max(dataset_subtype) as dataset_subtype, max(organism) as organism
                 from (  select dataset_name, dataset_type, dataset_subtype, organism
                         from &prefixInferredChars
                       union
                         select dataset_name, dataset_type, dataset_subtype, organism
                         from &prefixInferredParams
                       union
                         select dataset_name, dataset_type, dataset_subtype, organism
                         from &prefixDefaultChars)
                 group by dataset_name)
        select nvl(term_synonym.name, ot.name) as ontology_term_name, dot.ontology_term_id,
               ot.source_id as ontology_term_source_id,
               term_synonym.definition as description,
               nvl(term_synonym.name,
                   case ot.name
                     when 'env_feature' then 'Habitat'
                     when 'data set' then 'Data Set'
                     when 'obsolete_average mapping coverage' then 'Average mapping coverage'
                     else ot.name
                   end) as display_name,
               term_synonym.display_order,
               term_synonym.variable,
               otv.variable_name,
               parent.parent_ontology_term_name, parent.parent_ontology_term_id,
               parent.parent_ontology_term_source_id, unit_term.name as units,
               cast(pt.type as varchar2(20)) as type,
               case
                 when pt.filter = 'range' then 1
                 else 0
               end as is_range,
               cast(1 as number(1)) as precision,
               di.organism, dot.dataset_name, di.dataset_type, di.dataset_subtype
        from DatasetOntologyTerm dot, DatasetOntologyVars otv, sres.OntologyTerm ot, &prefixHierarchyMap hmap,
             &prefixDatasetTerm term_synonym, &prefixPropertyType pt,
             sres.OntologyTerm unit_term, DatasetInfo di,
             (select orel.hierarchy_dataset_name, orel.child_ontology_term_id,
                     orel.parent_ontology_term_id, orel.parent_ontology_term_source_id,
                     nvl(dt.name, ot.name) as parent_ontology_term_name
              from &prefixOntologyRelation orel, sres.OntologyTerm ot, &prefixDatasetTerm dt
              where orel.parent_ontology_term_id = ot.ontology_term_id
                and orel.parent_ontology_term_id = dt.ontology_term_id(+)
                and orel.hierarchy_dataset_name = dt.hierarchy_dataset_name(+)
             ) parent
        where dot.ontology_term_id = ot.ontology_term_id
          and dot.ontology_term_id = otv.ontology_term_id(+)
          and dot.dataset_name = hmap.dataset_name
          and dot.ontology_term_id = term_synonym.ontology_term_id(+)
          and hmap.hierarchy_dataset_name = term_synonym.hierarchy_dataset_name(+)
          and dot.ontology_term_id = parent.child_ontology_term_id(+)
          and hmap.hierarchy_dataset_name = parent.hierarchy_dataset_name(+)
          and dot.unit_id = unit_term.ontology_term_id(+)
          and dot.dataset_name = di.dataset_name
          and dot.ontology_term_id = pt.property_id(+)
          and dot.dataset_name not in ('ISASimple_RSRC', 'ISA_RSRC')
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update &prefixOntology&1 o
        set type
            = (select max(object.name) -- e.g. "multifilter"
               from sres.OntologyRelationship orel,
                    sres.OntologyTerm predicate, sres.OntologyTerm object,
                    sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
                    &prefixHierarchyMap hmap
               where o.ontology_term_id = orel.subject_term_id
                 and orel.predicate_term_id = predicate.ontology_term_id
                 and predicate.source_id = 'EUPATH_0000271' -- "termType"
                 and orel.object_term_id = object.ontology_term_id
                 and orel.external_database_release_id = edr.external_database_release_id
                 and edr.external_database_id = ed.external_database_id
                 and ed.name = hmap.hierarchy_dataset_name
                 and hmap.dataset_name = o.dataset_name
              )
        where type is null
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index &prefixnmoidx1&1
        on &prefixOntology&1 (ontology_term_name, dataset_name, organism)
        tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create unique index &prefixnouqidx1&1
        on &prefixOntology&1 (ontology_term_name, ontology_term_source_id, dataset_name, dataset_type)
        tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update &prefixOntology&1
        set display_name = 'Organism'
        where lower(ontology_term_name) = 'parasite organism'
          and lower(substr(sys_context ('USERENV', 'SERVICE_NAME'), 1, 4)) = 'fung'
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="Samples" prefixEnabled="true">
    <comment>lots of columns for sample meta data. used for sample record
      </comment>
    <internalDependency name="InferredParams"/>
    <internalDependency name="PropertyType"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <ancillaryTable name="Participants"/>
    <ancillaryTable name="Observations"/>
    <ancillaryTable name="LightTraps"/>
    <ancillaryTable name="Households"/>
    <ancillaryTable name="Communitys"/>
    <program commandLine="buildPANRecordAttributesTT"/>
  </tuningTable>

  <!-- Renamed from MetadataType -->
  <tuningTable name="PropertyType" prefixEnabled="true">
    <comment>
       Data type and filter method for metadata properties.
    </comment>
    <internalDependency name="DefaultChars"/>
    <internalDependency name="InferredParams"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixPropertyType&1 NOLOGGING AS
        WITH pan_metadata
             AS (  SELECT property, value, property_id
                   FROM &prefixInferredParams
                 UNION
                   SELECT property, value, property_id
                   FROM &prefixInferredChars
                 UNION
                   SELECT property, value, property_id
                   FROM &prefixDefaultChars
                ),
             term_attributes
             AS (SELECT MAX(property) as property, property_id, COUNT(DISTINCT value) AS distinct_values,
                        MIN(apidb.is_number(value)) AS is_number,
                        MIN(apidb.is_date(value)) AS is_date
                 FROM pan_metadata
                 WHERE value IS NOT NULL
                 GROUP BY property_id
                )
        SELECT ta.property AS property, ot.ontology_term_id as property_id, ot.source_id as property_source_id,
               CASE
                 WHEN ta.is_date = 1
                   THEN 'date'
                 WHEN ta.is_number = 1
                   THEN 'number'
                 ELSE 'string'
               END AS type,
               CASE
                 WHEN ta.is_date = 1
                   THEN 'range'
                 WHEN ta.is_number = 1
                      AND ta.distinct_values > 10
                      AND lower(ta.property) NOT LIKE '%code%'
                   THEN 'range'
                 ELSE 'membership'
               END AS filter,
               ta.distinct_values
        FROM term_attributes ta, sres.OntologyTerm ot
        WHERE ta.property_id = ot.ontology_term_id(+)
       ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX proptypename_idx&1
          ON &prefixPropertyType&1 (property_id, property)
        TABLESPACE indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX proptypid_idx&1
          ON &prefixPropertyType&1 (property, property_id, type, filter)
        TABLESPACE indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        UPDATE &prefixPropertyType&1
        SET type = 'string', filter = 'membership'
        WHERE property = 'Family ID'
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="ComComObsIO" prefixEnabled="true">
    <comment>
      Metadata table specific for comunity to community observation relation
    </comment>
<!--
    <internalDependency name="PANIO"/>
-->
    <sql>
      <![CDATA[
create table &prefixComComObsIO&1 (
  community_id,
  community_observation_id,
  CONSTRAINT &prefixcomcomobsio_pk&1 PRIMARY KEY (community_id,community_observation_id) 
  )
  ORGANIZATION index
  nologging
  as
  select distinct input_pan_id as community_id, output_pan_id as community_observation_id
  from &prefixPANIO 
  where input_pan_type_source_id = 'EUPATH_0035127'
  and output_pan_type_source_id = 'EUPATH_0035127'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixcomcomobsio&1
          ON &prefixComComObsIO&1 (community_observation_id,community_id)
        TABLESPACE indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="ComHouseIO" prefixEnabled="true">
    <comment>
      Metadata table specific for comunity to community observation relation
    </comment>
<!--
    <internalDependency name="PANIO"/>
-->
    <sql>
      <![CDATA[
create table &prefixComHouseIO&1 (
  community_id,
  household_id,
  CONSTRAINT &prefixcomhouseio_pk&1 PRIMARY KEY (community_id,household_id) 
  )
  ORGANIZATION index
  nologging
  as
  select distinct input_pan_id as community_id, output_pan_id as household_id
  from &prefixPANIO 
  where input_pan_type_source_id = 'EUPATH_0035127'
  and output_pan_type_source_id = 'PCO_0000024'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixcomhouseio&1
          ON &prefixComHouseIO&1 (household_id,community_id)
        TABLESPACE indx
      ]]>
    </sql>
  </tuningTable>

<!-- note that there may be direct com to part outputs as not requirement that all participants have a house as per washB -->
  <tuningTable name="ComPartIO" prefixEnabled="true">
    <comment>
      Metadata table specific for comunity to participant relation
    </comment>
    <internalDependency name="ComHouseIO"/>
    <internalDependency name="HousePartIO"/>
    <sql>
      <![CDATA[
create table &prefixComPartIO&1 (
  community_id,
  participant_id,
  CONSTRAINT &prefixcompartio_pk&1 PRIMARY KEY (community_id,participant_id) 
  )
  ORGANIZATION index
  nologging
  as
  select distinct ch.community_id, hp.participant_id
  from &prefixComHouseIO ch,  &prefixHousePartIO hp
  where ch.household_id = hp.household_id
UNION
  select distinct input_pan_id as community_id, output_pan_id as participant_id
  from &prefixPANIO 
  where input_pan_type_source_id = 'EUPATH_0035127'
  and output_pan_type_source_id = 'EUPATH_0000096'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixpartcomio&1
          ON &prefixComPartIO&1 (participant_id,community_id)
        TABLESPACE indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="ComObsIO" prefixEnabled="true">
    <comment>
      Metadata table specific for comunity to observation relation
    </comment>
    <internalDependency name="ComPartIO"/>
    <internalDependency name="PartObsIO"/>
    <sql>
      <![CDATA[
create table &prefixComObsIO&1 (
  community_id,
  observation_id,
  CONSTRAINT &prefixcomobsio_pk&1 PRIMARY KEY (community_id,observation_id) 
  )
  ORGANIZATION index
  nologging
  as
  select distinct cp.community_id, po.observation_id
  from &prefixComPartIO cp,  &prefixPartObsIO po 
  where cp.participant_id = po.participant_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixobscomio&1
          ON &prefixComObsIO&1 (observation_id,community_id)
        TABLESPACE indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="ComSampleIO" prefixEnabled="true">
    <comment>
      Metadata table specific for comunity to sample relation
    </comment>
    <internalDependency name="ComObsIO"/>
    <internalDependency name="ObsSampleIO"/>
    <sql>
      <![CDATA[
create table &prefixComSampleIO&1 (
  community_id,
  sample_id,
  CONSTRAINT &prefixcomsampleio_pk&1 PRIMARY KEY (community_id,sample_id) 
  )
  ORGANIZATION index
  nologging
  as
  select distinct co.community_id, os.sample_id
  from &prefixComObsIO co,  &prefixObsSampleIO os 
  where co.observation_id = os.observation_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixsamplecomio&1
          ON &prefixComSampleIO&1 (sample_id,community_id)
        TABLESPACE indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="CommunityMD" prefixEnabled="true">
    <comment>
      Metadata table specific for community metadata in community filter
    </comment>
    <internalDependency name="Metadata"/>
    <internalDependency name="Ontology"/>
    <internalDependency name="ComComObsIO"/>
    <sql>
      <![CDATA[
create table &prefixCommunityMD&1 (
  ontology_term_name,
  community_id,
  string_value,
  number_value,
  date_value,
  CONSTRAINT &prefixcomunmd_pk&1 PRIMARY KEY (ontology_term_name,community_id,string_value) 
  )
  ORGANIZATION index
  nologging
  as 
select distinct m.property_source_id as ontology_term_name, 
 m.pan_id as community_id, m.string_value, m.number_value, m.date_value
 from &prefixMetaData m
 where m.property_source_id in (
 select distinct o.ontology_term_source_id
 from &prefixOntology o
     CONNECT BY o.parent_ontology_term_source_id = PRIOR o.ontology_term_source_id
     START WITH o.ontology_term_source_id in ('EUPATH_0035127')   
   )
 and m.pan_id not in (select distinct community_observation_id from &prefixComComObsIO)
      ]]>
    </sql>
  </tuningTable>
  
  <tuningTable name="CommunityObsMD" prefixEnabled="true">
    <comment>
      Metadata table specific for community observation metadata in community filter
    </comment>
    <internalDependency name="Metadata"/>
    <internalDependency name="Ontology"/>
    <internalDependency name="ComComObsIO"/>
    <sql>
      <![CDATA[
create table &prefixCommunityObsMD&1 (
  ontology_term_name,
  community_observation_id,
  string_value,
  number_value,
  date_value,
  CONSTRAINT &prefixcomunobsmd_pk&1 PRIMARY KEY (ontology_term_name,community_observation_id,string_value) 
  )
  ORGANIZATION index
  nologging
  as 
select distinct m.property_source_id as ontology_term_name, 
 m.pan_id as community_observation_id, m.string_value, m.number_value, m.date_value
 from &prefixMetaData m
 where m.property_source_id in (
 select distinct o.ontology_term_source_id
 from &prefixOntology o
     CONNECT BY o.parent_ontology_term_source_id = PRIOR o.ontology_term_source_id
     START WITH o.ontology_term_source_id in ('EUPATH_0035127')   
   )
 and m.pan_id in (select distinct community_observation_id from &prefixComComObsIO)
      ]]>
    </sql>
  </tuningTable>
  
  <tuningTable name="HouseholdMD" prefixEnabled="true">
    <comment>
      Metadata table specific for household filter in household record
    </comment>
    <internalDependency name="Metadata"/>
    <internalDependency name="Ontology"/>
    <sql>
      <![CDATA[
create table &prefixHouseholdMD&1 (
  ontology_term_name,
  household_id,
  household_observation_id,
  string_value,
  number_value,
  date_value,
  CONSTRAINT &prefixHhmd_pk&1 PRIMARY KEY (ontology_term_name,household_id,household_observation_id,string_value) 
  )
  ORGANIZATION index
  nologging
  as 
with iopo as (
select distinct hp.input_pan_id as household_id, po.output_pan_id as observation_id
from &prefixPANIO hp, &prefixPANIO po 
where hp.input_pan_type_source_id = 'PCO_0000024' and hp.output_pan_type_source_id = 'EUPATH_0000096'
and hp.output_pan_id = po.input_pan_id
and po.input_pan_type_source_id = 'EUPATH_0000096' and po.output_pan_type_source_id = 'EUPATH_0000738'
),
ioho as (
select distinct hp.input_pan_id as household_id, hp.output_pan_id as observation_id
from &prefixPANIO hp 
where hp.input_pan_type_source_id = 'PCO_0000024' and hp.output_pan_type_source_id = 'EUPATH_0000738'
),
iohh as (
select distinct hp.input_pan_id as household_id, hp.output_pan_id as observation_id
from &prefixPANIO hp 
where hp.input_pan_type_source_id = 'PCO_0000024' and hp.output_pan_type_source_id = 'PCO_0000024'
),
hhold as (
select * from (
 select distinct m.property_source_id as ontology_term_name, 
 CASE WHEN ioho.household_id is not null THEN ioho.household_id WHEN iopo.household_id is not null THEN iopo.household_id 
 WHEN iohh.household_id is not null THEN iohh.household_id ELSE m.pan_id END as household_id, 
 m.pan_id as household_observation_id, m.string_value, m.number_value, m.date_value
 from &prefixMetaData m, iopo, ioho, iohh
 where m.property_source_id in (
 select distinct o.ontology_term_source_id
 from &prefixOntology o
     CONNECT BY o.parent_ontology_term_source_id = PRIOR o.ontology_term_source_id
     START WITH o.ontology_term_source_id in ('PCO_0000024')   
   )
 and m.pan_id = iopo.observation_id(+)
 and m.pan_id = ioho.observation_id(+)
 and m.pan_id = iohh.observation_id(+)
 ))
 select * from (
 select * from hhold
 union
 select distinct m.property_source_id as ontology_term_name, 
 hh.household_id, hh.household_observation_id, m.string_value, m.number_value, m.date_value
 from &prefixMetaData m, (select distinct household_observation_id, household_id from hhold) hh
 where m.property_source_id = 'EUPATH_0000579'
 and m.pan_id = hh.household_observation_id
 )
 order by ontology_term_name
      ]]>
    </sql>
  </tuningTable>
  
  <tuningTable name="ParticipantMD" prefixEnabled="true">
    <comment>
      Metadata table specific for participant filter in participant record
    </comment>
    <internalDependency name="Metadata"/>
    <internalDependency name="PANIO"/>
    <internalDependency name="Ontology"/>
    <sql>
      <![CDATA[
create table &prefixParticipantMD&1 (
  ontology_term_name,
  participant_id,
  household_id,
  string_value,
  number_value,
  date_value,
  CONSTRAINT &prefixPpartmd_pk&1 PRIMARY KEY (ontology_term_name,participant_id,string_value) 
  )
  ORGANIZATION index
  nologging
  as select * from (
  select distinct m.property_source_id as ontology_term_name, m.pan_id as participant_id, io.input_pan_id as household_id, m.string_value, m.number_value, date_value
 from &prefixMetaData m, (select input_pan_id, output_pan_id from &prefixPANIO where input_pan_type_source_id = 'PCO_0000024') io
 where m.property_source_id in (
 select distinct o.ontology_term_source_id
 from &prefixOntology o
     CONNECT BY o.parent_ontology_term_source_id = PRIOR o.ontology_term_source_id
     START WITH o.ontology_term_source_id in ('EUPATH_0000096')   
   )
 and m.pan_id = io.output_pan_id(+)
 )
 order by ontology_term_name,participant_id
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="HousePartIO" prefixEnabled="true">
    <comment>
      Metadata table specific for household to participant relation
    </comment>
    <internalDependency name="PANIO"/>
    <sql>
      <![CDATA[
create table &prefixHousePartIO&1 (
  household_id,
  participant_id,
  CONSTRAINT &prefixhousepartio_pk&1 PRIMARY KEY (household_id,participant_id) 
  )
  ORGANIZATION index
  nologging
  as
  select distinct input_pan_id as household_id, output_pan_id as participant_id
  from &prefixPANIO 
  where input_pan_type_source_id = 'PCO_0000024'
  and output_pan_type_source_id = 'EUPATH_0000096'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixparthouseio&1
          ON &prefixHousePartIO&1 (participant_id,household_id)
        TABLESPACE indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="HouseObsIO" prefixEnabled="true">
    <comment>
      Metadata table specific for household to observation relation
    </comment>
    <internalDependency name="HousePartIO"/>
    <internalDependency name="PartObsIO"/>
    <sql>
      <![CDATA[
create table &prefixHouseObsIO&1 (
  household_id,
  observation_id,
  CONSTRAINT &prefixhouseobsio_pk&1 PRIMARY KEY (household_id,observation_id) 
  )
  ORGANIZATION index
  nologging
  as
  select hp.household_id, po.observation_id
  from &prefixPartObsIO po, &prefixHousePartIO hp
  where po.participant_id = hp.participant_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixobshouseio&1
          ON &prefixHouseObsIO&1 (observation_id,household_id)
        TABLESPACE indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="PartObsIO" prefixEnabled="true">
    <comment>
      Metadata table specific for participant to observation relation
    </comment>
    <internalDependency name="PANIO"/>
    <sql>
      <![CDATA[
create table &prefixPartObsIO&1 (
  participant_id,
  observation_id,
  CONSTRAINT &prefixpartobsio_pk&1 PRIMARY KEY (participant_id,observation_id) 
  )
  ORGANIZATION index
  nologging
  as
  select distinct input_pan_id as participant_id, output_pan_id as observation_id
  from &prefixPANIO 
  where input_pan_type_source_id = 'EUPATH_0000096' 
  and output_pan_type_source_id = 'EUPATH_0000738'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixobspartio&1
          ON &prefixPartObsIO&1 (observation_id,participant_id)
        TABLESPACE indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="ObsSampleIO" prefixEnabled="true">
    <comment>
      Metadata table specific for Observation to Sample relation
    </comment>
    <internalDependency name="PANIO"/>
    <sql>
      <![CDATA[
create table &prefixObsSampleIO&1 (
  observation_id,
  sample_id,
  CONSTRAINT &prefixobssampleio_pk&1 PRIMARY KEY (observation_id,sample_id) 
  )
  ORGANIZATION index
  nologging
  as
  select distinct input_pan_id as observation_id, output_pan_id as sample_id
  from &prefixPANIO 
  where input_pan_type_source_id = 'EUPATH_0000738' 
  and output_pan_type_source_id = 'EUPATH_0000609'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixsampleobsio&1
          ON &prefixObsSampleIO&1 (sample_id, observation_id)
        TABLESPACE indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="HouseSampleIO" prefixEnabled="true">
    <comment>
      Metadata table specific for household to observation relation
    </comment>
    <internalDependency name="HousePartIO"/>
    <internalDependency name="PartObsIO"/>
    <internalDependency name="ObsSampleIO"/>
    <sql>
      <![CDATA[
create table &prefixHouseSampleIO&1 (
  household_id,
  sample_id,
  CONSTRAINT &prefixhouseSampleio_pk&1 PRIMARY KEY (household_id,sample_id) 
  )
  ORGANIZATION index
  nologging
  as
  select hp.household_id, os.sample_id
  from &prefixPartObsIO po, &prefixHousePartIO hp, &prefixObsSampleIO os
  where po.participant_id = hp.participant_id
  and po.observation_id = os.observation_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixsplhouseio&1
          ON &prefixHouseSampleIO&1 (sample_id,household_id)
        TABLESPACE indx
      ]]>
    </sql>
  </tuningTable>
  
  <tuningTable name="PartSampleIO" prefixEnabled="true">
    <comment>
      Metadata table specific for participant to sample relation
    </comment>
    <internalDependency name="PartObsIO"/>
    <internalDependency name="ObsSampleIO"/>
    <sql>
      <![CDATA[
create table &prefixPartSampleIO&1 (
  participant_id,
  sample_id,
  CONSTRAINT &prefixPartSampleio_pk&1 PRIMARY KEY (participant_id,sample_id) 
  )
  ORGANIZATION index
  nologging
  as
  select po.participant_id, os.sample_id
  from &prefixPartObsIO po, &prefixObsSampleIO os
  where po.observation_id = os.observation_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixsplPartio&1
          ON &prefixPartSampleIO&1 (sample_id,participant_id)
        TABLESPACE indx
      ]]>
    </sql>
  </tuningTable>
  
  <tuningTable name="ObsObsIO" prefixEnabled="true">
    <comment>
      Metadata table specific for Observation to sub observation relation
    </comment>
    <internalDependency name="PANIO"/>
    <sql>
      <![CDATA[
create table &prefixObsObsIO&1 (
  observation_id,
  sub_observation_id,
  CONSTRAINT &prefixobsobs_pk&1 PRIMARY KEY (observation_id,sub_observation_id) 
  )
  ORGANIZATION index
  nologging
  as
  select distinct input_pan_id as observation_id, output_pan_id as sub_observation_id
  from &prefixPANIO 
  where input_pan_type_source_id = 'EUPATH_0000738' 
  and output_pan_type_source_id = 'EUPATH_0000738'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixsubobsobsio&1
          ON &prefixObsObsIO&1 (sub_observation_id, observation_id)
        TABLESPACE indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="HouseEntoIO" prefixEnabled="true">
    <comment>
      Metadata table specific for household to Entomology relation
    </comment>
    <internalDependency name="PANIO"/>
    <sql>
      <![CDATA[
create table &prefixHouseEntoIO&1 (
  household_id,
  entomology_id,
  CONSTRAINT &prefixhouseentoio_pk&1 PRIMARY KEY (household_id,entomology_id) 
  )
  ORGANIZATION index
  nologging
  as
  select distinct input_pan_id as household_id, output_pan_id as entomology_id
  from &prefixPANIO 
  where input_pan_type_source_id = 'PCO_0000024' 
  and output_pan_type_source_id = 'EUPATH_0000327'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixhouseentoio&1
          ON &prefixHouseEntoIO&1 (entomology_id,household_id)
        TABLESPACE indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="EntoInsSplIO" prefixEnabled="true">
    <comment>
      Metadata table specific for Entomology to insect sample relation
    </comment>
    <internalDependency name="PANIO"/>
    <sql>
      <![CDATA[
create table &prefixEntoInsSplIO&1 (
  entomology_id,
  insect_sample_id,
  CONSTRAINT &prefixentoinssplio_pk&1 PRIMARY KEY (entomology_id,insect_sample_id) 
  )
  ORGANIZATION index
  nologging
  as
  select distinct input_pan_id as entomology_id, output_pan_id as insect_sample_id
  from &prefixPANIO 
  where input_pan_type_source_id = 'EUPATH_0000327' 
  and output_pan_type_source_id = 'EUPATH_0025169'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixentoinssplio&1
          ON &prefixEntoInsSplIO&1 (insect_sample_id,entomology_id)
        TABLESPACE indx
      ]]>
    </sql>
  </tuningTable>

<!-- NOTE: this will NOT work for studies where sub observations have samples -->
  <tuningTable name="ObservationMD" prefixEnabled="true">
    <comment>
      Metadata table specific for observation filter 
    </comment>
    <internalDependency name="ObsObsIO"/>
    <internalDependency name="HousePartIO"/>
    <internalDependency name="PartObsIO"/>
    <internalDependency name="Metadata"/>
    <internalDependency name="ObsSampleIO"/>
    <internalDependency name="Ontology"/>
    <sql>
      <![CDATA[
create table &prefixObservationMD&1 (
  ontology_term_name,
  observation_id,
  participant_id,
  sub_observation_id,
  sample_id,
  household_id,
  string_value,
  number_value,
  date_value,
  CONSTRAINT &prefixObsmd_pk&1 PRIMARY KEY (ontology_term_name,observation_id,participant_id,sub_observation_id,sample_id,string_value) 
  )
  ORGANIZATION index
  nologging
  as
with obsont as (
select distinct o.ontology_term_source_id
 from &prefixOntology o
     CONNECT BY o.parent_ontology_term_source_id = PRIOR o.ontology_term_source_id
     START WITH o.ontology_term_source_id in ('EUPATH_0000738','EUPATH_0000609') /* NOTE: 'EUPATH_0000609' bring in sample vars attached directly to observations like for PRISM */
)
 select distinct m.property_source_id as ontology_term_name, m.pan_id as observation_id, ioo.participant_id,  m.pan_id as sub_observation_id, m.pan_id as sample_id, nvl(ioh.household_id,-1) as household_id, m.string_value, m.number_value, m.date_value
 from &prefixMetaData m, &prefixPartObsIO ioo, &prefixHousePartIO ioh
 where m.property_source_id in (
 select ontology_term_source_id
 from obsont  
   )
 and m.pan_id = ioo.observation_id
 and ioo.participant_id = ioh.participant_id(+) 
UNION  -- NOTE: the following pulls in sub-observations for an observation but maintains as separate observations 
 select distinct m.property_source_id as ontology_term_name, iosub.observation_id as observation_id, ioo.participant_id, m.pan_id as sub_observation_id, iosub.observation_id as sample_id,
 nvl(ioh.household_id,-1) as household_id, m.string_value, m.number_value, m.date_value
 from &prefixMetaData m, &prefixObsObsIO iosub,  &prefixHousePartIO ioh, &prefixPartObsIO ioo
 where m.property_source_id in (
 select ontology_term_source_id
 from obsont  
   )
 and m.pan_id = iosub.sub_observation_id
 and iosub.observation_id = ioo.observation_id
 and ioo.participant_id = ioh.participant_id(+)
UNION --NOTE: next block pulls in sample information
select distinct m.property_source_id as ontology_term_name, ioo.observation_id,ioo.participant_id, ioo.observation_id as sub_sample_id, m.pan_id as sample_id, nvl(ioh.household_id,-1) as household_id,  m.string_value, m.number_value, m.date_value
 from &prefixMetaData m, &prefixObsSampleIO spec, &prefixPartObsIO ioo, &prefixHousePartIO ioh
 where m.property_source_id in (
 select distinct o.ontology_term_source_id
 from &prefixOntology o
     CONNECT BY o.parent_ontology_term_source_id = PRIOR o.ontology_term_source_id
     START WITH o.ontology_term_source_id in ('EUPATH_0000609')   
   )
 and m.pan_id = spec.sample_id
      and ioo.observation_id = spec.observation_id
      and ioo.participant_id = ioh.participant_id(+)     
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixObsmd_partid&1
          ON &prefixObservationMD&1 (participant_id, observation_id)
        TABLESPACE indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixObsmd_obsid&1
          ON &prefixObservationMD&1 (observation_id, participant_id)
        TABLESPACE indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="SampleMD" prefixEnabled="true">
    <comment>
      Metadata table specific for sample filter 
    </comment>
    <internalDependency name="ObservationMD"/>
    <sql>
      <![CDATA[
create table &prefixSampleMD&1 (
  ontology_term_name,
  sample_id,
  observation_id,
  participant_id,
  household_id,
  string_value,
  number_value,
  date_value,
  CONSTRAINT &prefixSmplmd_pk&1 PRIMARY KEY (ontology_term_name,sample_id,observation_id,participant_id,string_value) 
  )
  ORGANIZATION index
  nologging
  as
  select ontology_term_name, sample_id, observation_id, participant_id, household_id, string_value, number_value, date_value
  from &prefixObservationMD
  where sample_id != observation_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixSplmd_obsid&1
          ON &prefixSampleMD&1 (observation_id, sample_id)
        TABLESPACE indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="EntomologyMD" prefixEnabled="true">
    <comment>
      Metadata table specific for observation filter 
    </comment>
    <internalDependency name="HouseEntoIO"/>
    <internalDependency name="EntoInsSplIO"/>
    <internalDependency name="Metadata"/>
    <sql>
      <![CDATA[
create table &prefixEntomologyMD&1 (
  ontology_term_name,
  entomology_id,
  household_id,
  insect_sample_id,
  string_value,
  number_value,
  date_value,
  CONSTRAINT &prefixEntmd_pk&1 PRIMARY KEY (ontology_term_name,entomology_id,household_id,insect_sample_id,string_value) 
  )
  ORGANIZATION index
  nologging
  as
   select distinct m.property_source_id as ontology_term_name, m.pan_id as entomology_id, io.household_id,  m.pan_id as insect_sample_id, 
   m.string_value, m.number_value, m.date_value
 from &prefixMetaData m, &prefixHouseEntoIO io
 where m.pan_id = io.entomology_id
UNION  -- NOTE: the following pulls in insect sample data
   select distinct m.property_source_id as ontology_term_name, eis.entomology_id, io.household_id,  m.pan_id as insect_sample_id, 
   m.string_value, m.number_value, m.date_value
 from &prefixMetaData m, &prefixHouseEntoIO io, &prefixEntoInsSplIO eis
 where m.pan_id = Eis.Insect_Sample_Id
 and Eis.Entomology_Id = io.entomology_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixEntomd_houseid&1
          ON &prefixEntomologyMD&1 (household_id, entomology_id)
        TABLESPACE indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="RecordCount" prefixEnabled="false">
    <comment>generates the counts for each type_id for each study in study.protocolappnode.
    </comment>
    <internalDependency name="DatasetPresenter"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
        create table RecordCount&1 nologging as
        with coredata as (
        select inv.algorithm_invocation_id, inv.comment_string, o.ontology_term_id,o.name,count(*) as record_count
        from study.protocolappnode pan, sres.ontologyterm o, core.algorithminvocation inv
        where o.ontology_term_id = pan.type_id
        and inv.algorithm_invocation_id = pan.row_alg_invocation_id
        and pan.protocol_app_node_id not in (
           select distinct panout.protocol_app_node_id
           from study.input, study.output, study.protocolappnode panin, study.protocolappnode panout, sres.ontologyterm otin, sres.ontologyterm otout
           where input.protocol_app_id = output.protocol_app_id
           and input.protocol_app_node_id = panin.protocol_app_node_id
           and panin.type_id = otin.ontology_term_id
           and otin.name = 'Household'
           and output.protocol_app_node_id = panout.protocol_app_node_id
           and panout.type_id = otout.ontology_term_id
           and otout.name = 'Household'
           )
        group by inv.algorithm_invocation_id,inv.comment_string, o.ontology_term_id,o.name
        )
        select dp.dataset_presenter_id, dp.name, dp.display_name, t.name as record_type, t.record_count
        from apidbtuning.datasetpresenter dp,  coredata t
        where dp.name = regexp_replace(regexp_substr(t.comment_string,'extDbRlsSpec\s+["'']\S+RSRC'),'extDbRlsSpec\s+["'']','')
      ]]>
    </sql>
    <sql>
      <![CDATA[
        INSERT INTO RecordCount&1
        SELECT tp.dataset_presenter_id,dp.name,dp.display_name, 'Variable' AS RECORD_TYPE, count(o.ONTOLOGY_SYNONYM_ID) AS RECORD_COUNT
        FROM apidbtuning.DATASETProperty tp
        LEFT JOIN apidbtuning.datasetpresenter dp ON tp.dataset_presenter_id=dp.dataset_presenter_id
        LEFT JOIN sres.EXTERNALDATABASE e ON e.name= 'OntologyTerm_' || tp.value || '_RSRC'
        LEFT JOIN sres.EXTERNALDATABASERELEASE rel ON e.EXTERNAL_DATABASE_ID = rel.EXTERNAL_DATABASE_ID 
        LEFT JOIN sres.ONTOLOGYSYNONYM o ON rel.EXTERNAL_DATABASE_RELEASE_ID = o.EXTERNAL_DATABASE_RELEASE_ID 
        WHERE tp.property='webDisplayOntologyName'
        GROUP BY tp.dataset_presenter_id,dp.name,dp.display_name
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index rcd_ct_ix&1
        on RecordCount&1 (dataset_presenter_id, record_type)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>

</tuningConfig>
